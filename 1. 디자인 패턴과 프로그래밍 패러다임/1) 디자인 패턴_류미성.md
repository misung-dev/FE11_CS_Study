# 👩🏻‍💻 디자인 패턴과 프로그래밍 패러다임

## 1.1 디자인 패턴

### 1.1.1 싱글톤 패턴

- 개념:
  - 메모리 절약을 위해, 인스턴스가 필요할 때 똑같은 인스턴스를새로 만들지 않고 기존의 인스턴스를 가져와 활용하는 기법
  - 자바스크립트, 자바, mongoose, MySQL 등에서 사용할 수 있지만 가장 많이 쓰이는 곳은 데이터베이스 모듈
- 장점: 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스 생성비용 줄어든다
- 단점: 의존성이 높아진다 (단위 테스트를 주로하는 TDD에서 불리)

  - 의존성 주입을 통해 모듈간의 결합을 느슨하게 할 수 있음

  <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ-vpCY5F3L_YlRst5QJUtYVgAuIXrBQtAiPQ&s'>
  <img height=200 src='https://refactoring.guru/images/patterns/content/singleton/singleton.png?id=108a0b9b5ea5c4426e0afa4504491d6f'>
  <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRxiZKTxODJSie_WV9egURcEpSUYljMYqHJpw&s'>

- 의존성 주입
  - 장점? 모듈들을 쉽게 교체 가능 → 테스팅 쉽고, 마이그레이션 수월, 의존성 방향 일관 등
  - 단점? 분리되는 모듈로 인해 클래스 수가 늘어나 복잡성 증가, 런티아미 페털티 등
  - 잘 하려면(=원칙)?
    - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않기
    - 둘다 추상화에 의존하기

### 1.1.2 팩토리 패턴

- 개념
  - 제품 객체들을 도맡아 생성하는 공장 클래스를 만들고, 이를 상속하는 서브 공장 클래스의 메서드에서 여러가지 제품 객체 생성을 각각 책임 지는 것
  - 상위 클래스가 중요한 뼈대 결정, 하위 클래스가 객체 생성에 관한 구체적인 내용 결정 (상속 관계)
- 장점
  - 생성자(Creator)와 구현 객체(concrete product)의 강한 결합 피할 수 있음
  - 단일 책임 원칙, 개방/폐쇄 원칙 준수
- 단점
  - 각 제품 구현체마다 팩토리 객체들을 모두 구현해야함 → 구현체가 늘어날때마다 팩토리 클래스 증가하여 서브 클래스가 폭발적으로 증가
- 적용 시점

  - 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
  - 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때

  <img height=200 src='https://www.omnibuscode.com/board/files/attach/images/372/134/007/c9e8e59ab5034ff6cfc1c7aa2f27bed8.jpg'>

### 1.1.3 전략 패턴 (=정책 패턴)

- 개념
  - 객체의 행위를 변경하고 싶은 경우 **직접 수정하지 않고** 전략이라 불리는 **캡슐화한 알고리즘을 변경해줌으로써 유연하게 확장하는 방법**
- passport의 전략 패턴 예시
  - Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리
  - 여러 가지 전략으로 인증 가능
    - LocalStrategy: 서비스 내의 회원가입된 아이디와 비밀번호 기반
    - OAuth: 페이스북, 네이버 등 다른 서비스 기반
- 장점
  - 알고리즘을 정의하고 캡슐화하여 런타임 시에 알고리즘 선택하는 데 사용
    - 알고리즘을 쉽게 변경 및 대체 가능 → 유연함, 확장성 증가
    - 알고리즘 캡슐화 → 재사용성 좋음
    - 각각 알고리즘을 독립적으로 테스트 가능 → 테스트 용이
- 단점
  - 추가적인 클래스 및 인터페이스 필요 → 코드 복잡성 증가
  - 런타임 시에 알고리즘 선택 → 추가 오버헤드 발생
  - 전략 패턴 설계 어려움

### 1.1.4 옵저버 패턴

- 개념
  - 일대 다 관계
  - 어떤 객체의 상태가 변할 때 그와 연관된 객체 들에게 알림을 보내는 디자인 패턴
  - MVC 패턴에도 사용됨
- 장점
  - 실시간으로 한 객체의 변경사항을 다른 객체에 전파할 수 있다.
  - 느슨한 결합(Loose Coupling)으로 시스템이 유연하고 객체간의 의존성을 제거할 수 있다.
- 단점
  - 너무 많이 사용할 경우 상태 관리가 힘들 수 있다.
  - 데이터 배분에 문제가 발생하면 큰 문제로 발전할 수 있다.
- 적용 시점

  - 관심 객체의 상태 변화를 감지하고 자동으로 반응해야 하는 경우
  - 여러 객체가 하나의 객체에 의존하여 상태가 변경될 때마다 통지를 받아야 하는 경우

  <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSJ_eaGRO75DAcXOh7_BjtHS1UsVB9UyTrqCw&s'>

### 1.1.5 프록시 패턴과 프록시 서버

- 개념
  - 대상 원본 객체를 대리하여 대신 처리하게 함으로써 로직의 흐름을 제어하는 행동 패턴
  - 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
  - 속성, 변환 등을 보완하면서 보안, 데이터 검증, 캐싱, 로깅에 사용
- 프록시 서버
  - 개념
    - 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
    - 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는 것
  - 장점
    - 불필요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다
    - DDOS 공격 방어, HTTPS 구축
  - 예시
    - nginx, Cloudflare 등

### 1.1.6 이터레이터 패턴

- 개념
  - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공해 주는 패턴
  - 이터레이터 패턴을 사용하면 집합체 내에서 어떤 식으로 일이 처리되는지 몰라도 그 안에 들어있는 항목들에 대해서 반복작업 수행 가능
- 장점
  - 집합체 클래스의 응집도를 높여줌
  - 집합체 내에서 어떤 식으로 일이 처리되는지 알 필요 없이, 집합체 안에 들어있는 모든 항목에 접근 가능
- 단점
  - 단순한 순회를 구현하는 경우 클래스만 많아져 복잡도가 증가할 수 있음
- 적용 시점

  - 다양한 형태의 컬렉션이나 집합체 내부의 요소를 순차적으로 접근하고 싶지만, 각 컬렉션의 내부 구조를 클라이언트에 노출하고 싶지 않을 때

  <img height=200 src='https://refactoring.guru/images/patterns/content/iterator/iterator-ko.png?id=a29a593168960cbd5a2788d2ff4ecd03'>

### 1.1.7 노출모듈 패턴

- 개념
  - 즉시 실행 함수를 통해 private이나 public 같은 접근 제어자를 만드는 패턴
  - 정보 은닉(필요한 부분만 노출), 외부 노출 제어(내부 구현의 변경이 외부 코드에 영향을 미치지 않음)
  - 자바에서 주로 사용
- 장점
  - 캡슐화 강화: 외부에서 불필요한 내부 구조에 접근할 수 없음 → 보안성 강화
  - 코드 유지보수성: 내부 구현을 변경하더라도 외부 인터페이스가 일정하면, 외부 코드에 영향을 미치지 않고 유연하게 수정 가능
- 단점
  - 비공개(private) 함수에 직접 접근할 방법 없음 → 테스트 어려움
- 적용시점
  - **정보 은닉과 캡슐화를 구현하고 싶을 때**

### 1.1.8 MVC 패턴

- 개념
  - 가장 보편화 되고, 가장 단순한 패턴
  - M-V-C의 상호작용
    - 사용자가 애플리케이션에서 작업을 수행하면,
    - 뷰(View)는 사용자의 입력을 감지하고 컨트롤러(Controller)에 전달
    - 컨트롤러는 사용자 입력을 처리하고 적절한 모델(Model) 기능을 호출하여 데이터를 검색, 수정 또는 저장
    - 모델은 데이터와 관련된 비즈니스 로직을 수행하고, 필요한 경우 데이터베이스와 상호 작용. 작업이 완료되면 결과를 컨트롤러에 반환
    - 컨트롤러는 모델의 결과를 받아 뷰에 전달
    - 뷰는 이 데이터를 사용하여 사용자에게 보여지는 화면을 업데이트
- 구성 요소
  - 모델(Model)
    - 애플리케이션의 핵심 데이터와 비즈니스 로직을 나타냅니다. 데이터 저장소와의 상호 작용, 데이터 처리 및 유효성 검사와 같은 작업을 수행합니다. 모델은 독립적으로 작동하며, 뷰와 컨트롤러와 직접적으로 통신하지 않습니다.
  - 뷰(View)
    - 사용자에게 보여지는 애플리케이션의 UI 부분입니다. 뷰는 1) 모델에서 데이터를 받아 사용자에게 표시하고, 사용자의 2) 입력을 컨트롤러에 전달합니다. 뷰는 애플리케이션의 데이터 표시와 관련된 모든 작업을 처리합니다.
  - 컨트롤러(Controller)
    - 사용자 입력을 처리하고, 애플리케이션의 흐름을 관리합니다. 뷰에서 전달된 사용자 입력을 분석하고, 적절한 모델 기능을 호출하여 데이터를 조작하거나 업데이트합니다. 그런 다음 결과를 다시 뷰에 전달하여 화면에 표시할 수 있습니다.
- 장점
  - 각 컴포넌트가 독립적인 책임을 가지므로 코드의 이해와 관리가 쉬움
  - 특정 컴포넌트(예: 뷰)의 변경이 다른 컴포넌트(예: 모델)에 미치는 영향을 최소화, 새로운 뷰를 추가하거나 기존 뷰를 수정하기 용이 → **유연성 및 확장성 향상**
  - 모델은 특정 뷰에 종속되지 않으므로 다른 컨텍스트에서도 재사용될 수 있음 → 재사용성 증가
- 단점

  - 간단한 애플리케이션의 경우, MVC 패턴을 적용하면 오히려 클래스 수가 늘어나고 구조가 더 복잡해 보일 수 있음

    <img height=300 src='https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F7LWEM%2Fbtr6tWeyVZ7%2FAAAAAAAAAAAAAAAAAAAAADcBtHogaUM6yhUdmaxXCWZiMWML2I7hP6DoGi3pWIUn%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DTZZ9JD0hgQalHmMV7pX%252FEgB1Tfs%253D'>
    <img height=300 src='https://cdn.promleeblog.com/posts/250528-132454.webp'>

### 1.1.9 MVP 패턴

- 개념
  - MVC로부터 파생
  - 컨트롤러 대신 프레젠터로 교채된 패턴
- 장점
  - View와 Model간의 의존성이 없고, UI와 비즈니스 로직을 구분했기 때문에 유닛 테스트 용이
- 단점
  - View와 Presenter는 1대 1 관계이기 때문에 Presenter를 재사용 할 수 없음
  - 기능이 많아질수록 Presenter가 거대해짐
  - 프로젝트의 규모가 커질 수록 MVP패턴 구조를 유지하고 관리하는 것이 어려워질수 있다.
- MVC 안쓰고 왜 MVP를 쓰는가 ?

  - 분리된 책임: MVP패턴은 비즈니스 로직(Model)과 사용자 인터페이스(View)를 분리하여 관리하므로 코드의 가독성과 유지보수성이 향상된다.
    - MVC는 Model과 View가 서로 연결되어 있어 의존관계를 갖게 된다.
    - 그러나 MVP는 Model과 View 분리되어 있고 오직 Presenter를 통해서 상태나 변화를 알려줄 수 있다.
  - 테스트 용이성: View와 Presenter가 독립적으로 동작하므로 단위 테스트를 작성하기가 더 쉽다. Presenter는 View를 모의(Mock)해서 테스트할 수 있으며, Model은 별도로 테스트할 수 있습니다.

  <img height=200 src='https://velog.velcdn.com/images/ilil1/post/9ada8d0c-3fc6-4f87-a978-7d66b039b105/image.png'>

### 1.1.10 MVVM 패턴

- 개념
  - **Model View ViewModel**
  - **코드를 구성할 때 각각의 역할에 따라 코딩하는 디자인 패턴**
- 장점
  - 뷰 로직과 비지니스 로직을 분리하여 생산성을 높힐 수 있다. (UI가 나오지 않아도 개발 가능)
  - 테스트가 수월해진다. (의존성이 없기 때문)
  - 뷰와 뷰모델이 1:n 관계이기 때문에 중복되는 로직을 모듈화 해서 여러 뷰에 적용할 수 있다. (코드 재사용 가능)
- 단점
  - 설계하기가 복잡 (x데이터 바인딩에 대한 지식 필요)
  - 뷰모델이 비대해질 수 있다.
  - 데이터 바인딩으로 인한 메모리 소모가 심하다.
- MVP vs **MVVM**

  - MVP는 View와 Presenter 사이의 의존관계가 1:1로 형성되어있다면,
  - **MVVM은 View와 ViewModel사이의 관계가 1대n**으로 되어있습니다. 또한 데이터 바인딩을 이용한다면 **View**와 **ViewModel** 사이의 의존성을 없앨 수 있다.

    <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR2QXgFVuuD_Ig_a9eM-aKY1AEccVp39D2n0A&s'>
    <img height=200 src='https://velog.velcdn.com/images/kyeun95/post/31b13f9b-c0e0-4c7f-8760-7ec5bfb9bdc4/image.png'>

## 1.2 프로그래밍 패러다임

- 개념

  - 프로그래밍의 스타일
  - 개발자로 하여금 프로그래밍할 때에 관점을 제시

  <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS9RZBM52Z1HgUv0lOizjyAWI9EUAfQeWDO4g&s'>

### 1.2.1 선언형과 함수형 프로그래밍

- 함수가 최소 단위이며, 외부 상태를 갖지 않는 함수들을 통해 파이프 형태로 프로그래밍
  - 외부 상태를 갖지 않는 함수?
    - 같은 입력을 넣으면 언제나 같은 출력이 나옴
    - 어떤 외부 요인도 함수의 입출력에 영향을 주지 않음
- 모든 데이터의 처리를 수학적 함수로 취급
- 장점
  - 안정적, 동시성을 가지는 프로그램에 적합 (병렬 처리)
- 단점
  - 외부 상황 통제 필요
  - 온전한 함수형 프로그래밍을 구성하려면, 다양한 함수 조합 필요

### 1.2.2 객체지향 프로그래밍

- 객체를 최소 단위로 두며, 객체에 책임을 명확히 하여 각각 객체끼리 상호작용 하도록 설계
- 각각의 객체마다 각각의 데이터와 메소드(함수)를 가지고 있음. 각각의 데이터와 메소드(함수)는 경우에 따라 외부에서 접근 할수도 있고 보호 될수도 있음
- 객체와 객체 간의 메서드 호출로 이루어지고, 각 객체는 자신의 기능을 수행하는데 필요한 데이터를 직접 가지고 있음
- 추상화, 캡슐화, 상속성, 다형성 특징 가짐
- SOLID 원칙 준수
- 장점
  - 코드 확장 가능
  - 직관전이고, 유지보수 가능
- 단점
  - 객체에 대한 이해 필요
  - 설계에 많은 시간 소요
  - 처리 속도 느림

### 1.2.3 절차형 프로그래밍

- 함수 호출을 중심
  - 전체 로직에서 재사용성이 높은 코드들을 별도의 함수로 분리해 필요할 때마다 해당 함수 호출
- top-down 방식의 프로그래밍 (추상적인 개념을 구체화)
- 장점
  - 알고리즘이 명확. 기능 확장 등이 일어나지 안는 상황에서 사용하기 좋음
  - 순차적으로 함수를 불러오기 때문에, 함수의 역할만 알면 전반적인 프로그램 목적을 이해하기 좋음
- 단점
  - 프로그램이 복잡해질수록 함수가 많아지지만 데이터는 main에서 관리하므로 프로그램의 방향성을 이해하기 어려워지며 유지보수도 어려워집니다.

###
