# ⚙️ 운영체제

- 운영체제?
  - 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스
  - 한정된 메모리나 시스템 자원을 효율적으로 분배
  - 예: Windows, macOS, Linux 등
- 컴퓨터 시스템 간략 구조도

  <img height=200 src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcOkGK5%2FbtsjmCGpJkH%2FAAAAAAAAAAAAAAAAAAAAAN4aUVFgMlwywgrQyyJWJBBxZ0VoM_b3vZdjQnL16FXA%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DmxhmV7MJg7qxBKhjvZWX5i3LafU%253D'>

## 3.1 운영체제와 컴퓨터

### 3.1.1 운영체제의 역할과 구조

- 운영체제 역할

  - `메모리 관리`
    - 여러 프로그램이 동시에 실행될 때, 각 프로그램이 사용할 메모리 공간을 효율적으로 배분하고 관리
  - `CPU 스케줄링과 프로세스 관리`
    - 여러 프로그램이 동시에 실행될 때, CPU를 어떤 순서로 사용할지 정하고(스케줄링), 실행 중인 프로그램(프로세스)의 상태를 관리
  - `디스크 파일 관리`
    - 파일을 저장·삭제하고, 디렉토리 구조를 유지하며, 파일 접근 권한을 관리
  - `I/O 디바이스 관리`
    - 키보드, 마우스, 프린터 등 다양한 입출력 장치와 컴퓨터 간의 데이터 주고받기를 관리

  <img height=200 src='https://images.velog.io/images/0mi/post/b86b9c78-abab-4fe7-84ae-2d3f633e5511/image.png'>

- 운영체제 구조

  - `GUI` (Graphical User Interface)

    - 우리가 보는 화면 부분
    - 아이콘, 창, 버튼처럼 사용자가 쉽게 컴퓨터를 조작할 수 있게 해주는 그래픽 인터페이스
    - 예: 윈도우 바탕화면, 아이콘, 마우스 클릭

  - `시스템 콜` (System Call)

    - 프로그램이 운영체제에게 도움을 요청하는 통로
    - 예: 파일을 저장하거나, 새로운 프로그램을 실행할 때 OS에 “이거 해줘!”라고 말하는 것.

  - `커널` (Kernel)

    - 운영체제의 핵심
    - 메모리, CPU, 파일, 장치 같은 컴퓨터 자원을 직접 관리

  - `드라이버` (Driver)
    - 하드웨어 제어를 위한 소프트웨어
    - 운영체제와 하드웨어(장치) 사이를 연결해주는 번역기
    - 예: 프린터, 마우스, 그래픽카드를 OS가 이해하도록 도와주는 프로그램.

  <img height=300 src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcdWK5l%2FbtrXrT5lSdN%2FAAAAAAAAAAAAAAAAAAAAAAODO_pbKIaflDyFwDui_i0at2-jB5X2mEKwxxd7Ss0T%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DXXyxO5DjsNdc%252F%252B0BQ2EPQLAmZ%252Bo%253D'>

### 3.1.2 컴퓨터의 요소

- `CPU`
  - 명령을 해석하고 계산하며, 모든 작업을 지시·제어
- `DMA 컨트롤러`
  - CPU를 거치지 않고 입출력 장치가 메모리에 직접 데이터를 주고받게 도와주는 장치
  - CPU 부담을 줄여서 속도를 높여줌
- `메모리`
  - 프로그램과 데이터를 임시로 저장하는 공간
  - CPU가 작업할 때 필요한 정보를 빠르게 꺼내 쓸 수 있음
- `타이머`
  - 시간을 관리하는 장치
  - 시스템의 시간 관리 장치로, 일정 시간이 지나면 CPU에 인터럽트를 발생시켜 프로세스 전환이나 시간 제한 작업을 수행
- `디바이스 컨트롤러`
  - 키보드, 프린터 등 입출력 장치의 동작을 제어하고 운영체제와 하드웨어 간의 데이터 전송을 관리

👉 CPU는 처리, DMA는 전송, 메모리는 저장, 타이머는 시간 관리, 디바이스 컨트롤러는 입출력 관리 역할

  <img height=300 src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fbr9ET4%2FbtspepCNw1G%2FAAAAAAAAAAAAAAAAAAAAAJTSHWcI-hwXdomodavx9IarJh1KqF9mjjwWP0AKwFUm%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DP8mHRlFetUFZnX7GikDWcm6vppY%253D'>

## 3.2 메모리

### 3.2.1 메모리 계층

- 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 속도가 가장 빠름, 기억 용량이 가장 작다.
- 캐시: L1, L2 캐시를 지칭한다. 휘발성 빠름, 속도 빠름, 기억 용량이 적다. 참고로 L3 캐시도 있다.
- 주기억장치: RAM을 가리킨다. 휘발성 보통, 속도 보통, 기억 용량은 보통이다.
- 보조기억장치: HDD, SSD를 일컬으며 휘발성 낮음, 속도 낮음, 기억 용량이 많다.

  <img height=200 src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FWbzMH%2FbtrEPaYmrLV%2FAAAAAAAAAAAAAAAAAAAAAOvv7K0Q8i6K4PRmp5rv9l6OECyONWW3UCsb_7QWUl-Y%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DPsAVv%252B7%252BhBZoYmyNIrDSy16s3iw%253D'>

- `캐시`

  - 정의: CPU와 주기억장치(RAM) 사이에 있는 빠른 임시 저장 공간으로, 자주 사용하는 데이터를 미리 저장해 처리 속도를 높임 (= 고속 임시 저장소)
  - 목적: CPU가 매번 느린 메모리(RAM)에 접근하지 않도록 해 실행 속도를 향상
    ++ 지역성의 원리: 최근에 사용된 데이터나 그 근처의 데이터가 곧 다시 사용될 가능성이 높음
    - `시간 지역성`: 최근에 사용한 데이터에 다시 접근하려는 특성
    - `공간 지역성`: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

- `캐시히트`

  - 설명: CPU가 요청한 데이터가 캐시에 이미 존재할 때 발생
  - 결과: 빠르게 데이터를 가져와 처리 속도가 빨라짐

- `캐시미스`

  - 설명: CPU가 요청한 데이터가 캐시에 없는 경우 발생
  - 결과: RAM(또는 더 아래 단계의 저장장치)에서 데이터를 불러와야 하므로 처리 속도가 느림

    <img height=200 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSD_SVIqFqk9tFfv2atxe-9Yqj40EWtprSPDw&s'>

### 3.2.2 메모리 관리

운영체제는 **한정된 메모리를 최대한 효율적으로 활용**하기 위해 다양한 기법을 사용한다.

  <img height=300 src='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FlSrhi%2FbtrEOuvwv3W%2FAAAAAAAAAAAAAAAAAAAAABT6C0INHehJDwi7fZIrURaPELFcaD8v_XRopnMUHYxk%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DGMGRWj%252BnwU8bW%252BTuykxbTFN%252BUtI%253D'>

- `가상 메모리`
  - 실제 물리 메모리보다 더 큰 메모리 공간을 사용하는 것처럼 보이게 하는 기술
  - 가상 주소는 메모리관리장치(MMU)에 의해 실제 주초로 변환되며, 덕분에 사용자는 실제 주소를 의식할 필요 없이 프로그램 구축 가능.
  - 하드디스크의 일부를 메모리처럼 활용하여 여러 프로그램이 동시에 실행될 수 있게 한다.
- `스레싱`
  - 개념: 컴퓨터가 실제 작업보다 페이지 교체(메모리 ↔ 디스크) 작업에 더 많은 시간을 쓰는 현상
  - 원인: 실행 중인 프로그램이 너무 많거나, 메모리가 부족해서 가상 메모리 사용이 과도할 때 발생
  - 결과: CPU는 놀고, 메모리만 바쁘게 데이터를 옮기느라 전체 시스템 속도가 급격히 느려진다.
- `메모리 할당`
  - 프로세스에 필요한 만큼의 메모리를 분배하고 관리하는 과정이다.
  - **연속 할당**(하나의 큰 공간)과 **분산 할당**(여러 조각으로 나누는 방식)이 있다.
- `페이지 교체 알고리즘`
  - `오프라인 알고리즘`
    - 앞으로 가장 오래 사용되지 않을 페이지를 교체하는 방식이다.
    - 실제로 미래를 알 수 없기 때문에 이론적인 기준 알고리즘으로 사용된다.
  - `FIFO` (First In, First Out)
    - 가장 먼저 들어온 페이지를 가장 먼저 교체하는 방식이다.
    - 단순하지만, 오래된 페이지가 여전히 자주 사용될 수 있다는 단점이 있다.
  - `LRU`(Least Recently Used)
    - 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식이다.
    - 최근에 사용된 페이지는 다시 사용할 가능성이 높다는 가정을 기반으로 한다.

## 3.3 프로세스와 스레드

### 3.3.1 프로세스와 컴파일 과정

- `전처리`

  - 소스 코드에서 주석을 제거하고, 매크로를 처리하며, 필요한 헤더 파일을 포함시키는 단계

- `컴파일러`

  - 전처리된 소스 코드를 어셈블리어로 변환하여 문법 오류를 검사하고, 최적화된 중간 코드를 생성

- `어셈블러`

  - 어셈블리어 코드를 기계어(목적 코드)로 변환하여 실행 가능한 형태로 만듦

- `링커`

  - 여러 목적 파일과 라이브러리를 하나로 결합하여 최종 실행 파일을 생성

  <img height=300 src='https://velog.velcdn.com/images/ejdmswl/post/c3c4a477-8fe9-49d9-a0d7-9cb51fe3ada7/image.png'>

### 3.3.2 프로세스 상태

  <img height=200 src='https://thebook.io/img/080367/028.jpg'>

- `생성`

  - 프로세스가 메모리에 적재되어 실행 준비를 하는 단계

- `대기 상태`

  - CPU 할당을 기다리는 상태로, 실행 가능한 상태이지만 아직 CPU를 배정받지 못함

- `대기 중단 상태`

  - 메모리 부족 등으로 인해 보조기억장치에 저장되어 대기 중인 상태

- `실행 상태`

  - CPU를 할당받아 실제로 명령어를 실행 중인 상태

- `중단 상태`

  - 입출력 작업 등으로 인해 일시적으로 실행이 중단된 상태

- `일시 중단 상태`

  - 입출력 대기 중이면서 동시에 메모리에서 보조기억장치로 이동된 상태

- `종료 상태`
  - 모든 작업을 마치고 프로세스가 종료된 상태

### 3.3.3 프로세스의 메모리 구조

- 스택(Stack)

  - 함수 호출 시 생성되는 지역 변수, 매개변수, 반환 주소 등이 저장되는 공간
  - 함수가 호출될 때마다 새로 생성되고, 함수가 종료되면 사라짐 (LIFO 구조)

- 힙(Heap)

  - 프로그램 실행 중 동적으로 메모리를 할당받는 공간  
    사용자가 직접 관리해야 하며, 필요 시 malloc, new 등을 통해 할당하고 free, delete 등을 통해 해제함

- 데이터 영역(Data Segment)

  - 전역 변수와 static 변수가 저장되는 영역. 프로그램 시작 시 생성되어 종료 시까지 유지됨

- 코드 영역(Code Segment)

  - 실행할 프로그램의 명령어(기계어 코드)가 저장되는 영역

  <img height=200 src='https://velog.velcdn.com/images/gkqls813/post/abd6b95c-a2ff-43e0-b633-7bfc1a5b8bf4/image.png'>

### 3.3.4 PCB (Process Control Block)

- 프로세스 제어 블록으로, 운영체제가 각 프로세스를 관리하기 위해 유지하는 정보 구조체
- 프로세스의 상태, 프로그램 카운터, CPU 레지스터, 메모리 정보 등을 포함함
- 컨텍스트 스위칭 시 PCB의 정보를 저장하고 복원하여 여러 프로세스가 CPU를 번갈아 사용할 수 있도록 함

### 3.3.5 멀티프로세싱 (Multiprocessing)

- 하나의 컴퓨터에서 여러 개의 프로세스가 동시에 실행되는 방식
- 각 프로세스는 독립적인 메모리 공간을 가지며 서로 영향을 주지 않음
- 웹 브라우저는 탭마다 별도의 프로세스로 동작하여 한 탭이 오류를 일으켜도 전체가 종료되지 않음
- IPC(Inter-Process Communication)를 통해 프로세스 간 데이터를 주고받거나 동기화를 수행함

### 3.3.6 스레드와 멀티스레딩

- 스레드(Thread)

  - 프로세스 내에서 실행되는 작업 단위로, 같은 프로세스 내의 다른 스레드들과 메모리 자원을 공유함
  - 코드, 데이터, 힙은 공유하지만 스택은 각각 독립적으로 가짐

- 멀티스레딩(Multithreading)

  - 하나의 프로세스 내에서 여러 스레드를 동시에 실행시켜 병렬 처리와 응답성을 향상시키는 방식
  - 자원을 공유하기 때문에 동기화 문제가 발생할 수 있음

  <img height=300 src='https://velog.velcdn.com/images/sean2337/post/7afcf76c-c571-4f36-87ad-0c204621a941/image.png'>

### 3.3.7 공유 자원과 임계 영역

- 공유 자원(Shared Resource)

  - 여러 프로세스나 스레드가 동시에 접근할 수 있는 자원으로, 메모리나 파일, 프린터 등이 이에 해당함

- 임계 영역(Critical Section)

  - 동시에 접근하면 문제가 생기는 코드 영역으로, 한 번에 하나의 프로세스나 스레드만 진입해야 함

  - 뮤텍스(Mutex)  
    임계 영역에 한 번에 하나의 스레드만 접근하도록 상호 배제를 보장하는 잠금 방식

  - 세마포어(Semaphore)  
    접근 가능한 스레드의 개수를 제한할 수 있는 동기화 도구로, 여러 스레드가 공유 자원에 접근할 수 있도록 제어함
    <img height=300 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTtuYoy6omgyyIHJAdUOa2id9ehAjSCwBpn_w&s'>
    <img height=300 src='https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQeIafBEbnkxZQXljUi78W95pksJkLcsc71bA&s'>

### 3.3.8 교착 상태 (Deadlock)

- 교착 상태란 두 개 이상의 프로세스가 서로 자원을 기다리며 무한히 대기하는 상태

- 교착 상태의 발생 조건

  - 상호 배제(Mutual Exclusion) — 한 번에 한 프로세스만 자원을 사용할 수 있음
  - 점유 대기(Hold and Wait) — 자원을 가진 상태에서 다른 자원을 기다림
  - 비선점(No Preemption) — 다른 프로세스가 점유한 자원을 강제로 빼앗을 수 없음
  - 환형 대기(Circular Wait) — 여러 프로세스가 자원을 서로 기다리는 원형 대기 관계가 형성됨

- 교착 상태의 해결 방법

  - 예방(Prevention): 교착 상태가 발생하지 않도록 조건 중 하나를 제거함
  - 회피(Avoidance): 교착 상태가 일어날 가능성을 피하도록 자원 할당을 조절함 (예: 은행가 알고리즘)
  - 탐지(Detection): 교착 상태가 발생했는지 검사하고 발견 시 해결함
  - 복구(Recovery): 교착 상태가 발생한 프로세스를 강제 종료하거나 자원을 회수하여 시스템을 복구함

## 3.4 CPU 스케줄링 알고리즘

  <img height=200 src='https://blog.kakaocdn.net/dna/ulfjQ/btsGNZSGeiC/AAAAAAAAAAAAAAAAAAAAAJUqACYrj0cIB5PdK7MnEnmgXQqvNbSqsUFTCADsG3v-/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1761922799&allow_ip=&allow_referer=&signature=DMWjZTQ29IhcheByMZhZbt%2FDybA%3D'>

### 3.4.1 비선점형 방식

- 개념
  - 프로세스가 자발적으로 CPU 사용을 종료할 때까지 CPU를 계속 점유하는 방식이다.
  - 강제로 중단되지 않기 때문에 컨텍스트 스위칭에 따른 부하가 적다.
- 대표 알고리즘
  - `FCFS`(First Come, First Saved): 먼저 도착한 프로세스부터 처리하는 방식.
  - `SJF`(Shortest Job First): 실행 시간이 가장 짧은 프로세스를 먼저 처리하는 방식.
  - `우선 순위`: 우선순위가 높은 프로세스를 먼저 처리하는 방식.

### 3.4.2 선점형 방식

- 개념
  - 운영체제가 CPU를 강제로 회수할 수 있는 방식으로, 응답 속도가 빠르다.
  - 단, 잦은 컨텍스트 스위칭으로 시스템 부하가 증가할 수 있다.
- 대표 알고리즘
  - `라운드 로빈`(Round Robin): 일정 시간(타임 슬라이스)마다 프로세스를 교체하며 공평하게 CPU를 배분한다.
  - `SRF`(Shortest Remaining Time): 남은 실행 시간이 가장 짧은 프로세스에 CPU를 우선 배정한다.
  - `다단계 큐`(Multilevel Queue): 프로세스의 특성에 따라 여러 큐로 나누고, 각 큐별로 다른 스케줄링 방식을 적용한다.
